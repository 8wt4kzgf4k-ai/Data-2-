<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Forex Momentum + ROC Streak Analysis</title>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; }
  table { border-collapse: collapse; width: 100%; margin-top: 20px; font-size: 12px; }
  th, td { border: 1px solid #ccc; padding: 6px; text-align: center; }
  th { background-color: #f4f4f4; }
  .highlight { border: 2px solid red; font-weight: bold; }
</style>
</head>
<body>
<h1>Forex Momentum + ROC Streak Analysis</h1>
<p>Symbol: <strong id="symbol">EUR/USD</strong></p>
<p>Interval: <strong id="interval">5min</strong></p>

<h2>Heatmap: Frequency of Consecutive Candles</h2>
<p>Higher numbers = more streaks start in this zone</p>
<table id="heatmap">
  <thead>
    <tr>
      <th>Momentum \\ ROC</th>
      <!-- ROC bins added dynamically -->
    </tr>
  </thead>
  <tbody></tbody>
</table>

<h2>Top Zones</h2>
<p>Shows both: most frequent streaks & longest streaks</p>
<table id="topzones">
  <thead>
    <tr>
      <th>Direction</th>
      <th>Momentum Bin</th>
      <th>ROC Bin</th>
      <th>Streak Count</th>
      <th>Longest Streak</th>
    </tr>
  </thead>
  <tbody></tbody>
</table>

<script>
const API_KEY = 'YOUR_TWELVE_DATA_KEY'; // Replace with your key
const SYMBOL = 'EUR/USD';
const INTERVAL = '5min';
const MOM_LENGTH = 10;
const ROC_LENGTH = 14;
const MIN_CONSECUTIVE = 2;
const BIN_SIZE = 20; 
const BINS = [];
for(let i=-100;i<100;i+=BIN_SIZE) BINS.push(i);

// ----------------- Utility Functions -----------------
function normalizedMomentum(closeArr, index){
    const mom = closeArr[index] - closeArr[index - MOM_LENGTH];
    let maxAbs = 0;
    for(let i=index-MOM_LENGTH+1;i<=index;i++){
        if(i>=MOM_LENGTH){
            const m = Math.abs(closeArr[i]-closeArr[i-MOM_LENGTH]);
            if(m>maxAbs) maxAbs = m;
        }
    }
    if(maxAbs===0) return 0;
    return Math.max(-100, Math.min(100,(mom/maxAbs)*100));
}

function normalizedROC(closeArr,index){
    const r = ((closeArr[index]-closeArr[index-ROC_LENGTH])/closeArr[index-ROC_LENGTH])*100;
    let maxAbs=0;
    for(let i=index-ROC_LENGTH+1;i<=index;i++){
        if(i>=ROC_LENGTH){
            const tempR=Math.abs((closeArr[i]-closeArr[i-ROC_LENGTH])/closeArr[i-ROC_LENGTH]*100);
            if(tempR>maxAbs) maxAbs=tempR;
        }
    }
    if(maxAbs===0) return 0;
    return Math.max(-100, Math.min(100,(r/maxAbs)*100));
}

// ----------------- Fetch Data -----------------
async function fetchCandles(){
    const url = `https://api.twelvedata.com/time_series?symbol=${SYMBOL}&interval=${INTERVAL}&outputsize=5000&apikey=${API_KEY}`;
    const resp = await fetch(url);
    const data = await resp.json();
    if(data.status==="error"){ console.error(data); return []; }
    return data.values.reverse();
}

// ----------------- Heatmap Analysis -----------------
function analyzeHeatmap(candles){
    const closeArr = candles.map(c=>parseFloat(c.close));
    const heatmapBull={}, heatmapBear={};
    const streaksBull={}, streaksBear={};

    BINS.forEach(m=>{
        heatmapBull[m]={}; heatmapBear[m]={};
        streaksBull[m]={}; streaksBear[m]={};
        BINS.forEach(r=>{
            heatmapBull[m][r]=0; heatmapBear[m][r]=0;
            streaksBull[m][r]=[]; streaksBear[m][r]=[];
        });
    });

    let consecutiveCount=1;
    for(let i=Math.max(MOM_LENGTH,ROC_LENGTH);i<closeArr.length;i++){
        const mom=normalizedMomentum(closeArr,i);
        const roc=normalizedROC(closeArr,i);
        const dir=closeArr[i]>closeArr[i-1]? 'Bull':'Bear';
        const prevDir=closeArr[i-1]>closeArr[i-2]? 'Bull':'Bear';
        consecutiveCount=(dir===prevDir)? consecutiveCount+1:1;

        if(consecutiveCount>=MIN_CONSECUTIVE){
            const momBin=BINS.reduce((p,c)=>Math.abs(c-mom)<Math.abs(p-mom)?c:p,BINS[0]);
            const rocBin=BINS.reduce((p,c)=>Math.abs(c-roc)<Math.abs(p-roc)?c:p,BINS[0]);
            if(dir==='Bull'){
                heatmapBull[momBin][rocBin]++;
                streaksBull[momBin][rocBin].push(consecutiveCount);
            } else {
                heatmapBear[momBin][rocBin]++;
                streaksBear[momBin][rocBin].push(consecutiveCount);
            }
        }
    }
    return {heatmapBull, heatmapBear, streaksBull, streaksBear};
}

// ----------------- Render Heatmap -----------------
function renderHeatmap(heatmapBull, heatmapBear){
    const table = document.querySelector("#heatmap");
    const headerRow = table.querySelector("thead tr");
    headerRow.innerHTML='<th>Momentum \\ ROC</th>';
    BINS.forEach(rBin=>headerRow.innerHTML+=`<th>${rBin} to ${rBin+BIN_SIZE}</th>`);

    const tbody=table.querySelector("tbody");
    tbody.innerHTML='';

    BINS.forEach(mBin=>{
        const tr=document.createElement("tr");
        tr.innerHTML=`<td>${mBin} to ${mBin+BIN_SIZE}</td>`;
        BINS.forEach(rBin=>{
            const valBull=heatmapBull[mBin][rBin];
            const valBear=heatmapBear[mBin][rBin];
            const valTotal=valBull+valBear;
            const colorIntensity=Math.min(255,valTotal*20);
            tr.innerHTML+=`<td style="background-color: rgb(${255-colorIntensity},${255},${255-colorIntensity})">${valTotal}</td>`;
        });
        tbody.appendChild(tr);
    });
}

// ----------------- Find Top Zones -----------------
function getTopZones(heatmap, streaks, direction, type='count'){
    const zones=[];
    BINS.forEach(m=>BINS.forEach(r=>{
        const freq=heatmap[m][r];
        if(freq>0){
            let value;
            if(type==='count') value=freq; // most streaks
            else value=Math.max(...streaks[m][r]); // longest streak
            zones.push({momentum:m, roc:r, freq:freq, longest:Math.max(...streaks[m][r]), value});
        }
    }));
    zones.sort((a,b)=>b.value-a.value);
    return zones.slice(0,3).map(z=>({...z,direction}));
}

// ----------------- Render Top Zones -----------------
function renderTopZones(topBullCount, topBearCount, topBullLongest, topBearLongest){
    const tbody=document.querySelector("#topzones tbody");
    tbody.innerHTML='';

    // Most streaks
    [...topBullCount,...topBearCount].forEach(z=>{
        const tr=document.createElement("tr");
        tr.innerHTML=`<td>${z.direction} (Most Streaks)</td>
                        <td>${z.momentum} to ${z.momentum+BIN_SIZE}</td>
                        <td>${z.roc} to ${z.roc+BIN_SIZE}</td>
                        <td>${z.freq}</td>
                        <td>${z.longest}</td>`;
        tbody.appendChild(tr);
    });

    // Longest streaks
    [...topBullLongest,...topBearLongest].forEach(z=>{
        const tr=document.createElement("tr");
        tr.innerHTML=`<td>${z.direction} (Longest Streaks)</td>
                        <td>${z.momentum} to ${z.momentum+BIN_SIZE}</td>
                        <td>${z.roc} to ${z.roc+BIN_SIZE}</td>
                        <td>${z.freq}</td>
                        <td>${z.longest}</td>`;
        tbody.appendChild(tr);
    });
}

// ----------------- Main -----------------
async function main(){
    const candles=await fetchCandles();
    if(candles.length===0){ alert("No data fetched!"); return; }
    const {heatmapBull, heatmapBear, streaksBull, streaksBear}=analyzeHeatmap(candles);
    renderHeatmap(heatmapBull, heatmapBear);

    const topBullCount=getTopZones(heatmapBull, streaksBull,'Bull','count');
    const topBearCount=getTopZones(heatmapBear, streaksBear,'Bear','count');
    const topBullLongest=getTopZones(heatmapBull, streaksBull,'Bull','longest');
    const topBearLongest=getTopZones(heatmapBear, streaksBear,'Bear','longest');

    renderTopZones(topBullCount, topBearCount, topBullLongest, topBearLongest);
}

document.getElementById('symbol').innerText=SYMBOL;
document.getElementById('interval').innerText=INTERVAL;
main();
</script>
</body>
</html>
