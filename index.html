<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Forex Momentum + ROC Streak Alerts</title>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; }
  table { border-collapse: collapse; margin-top: 20px; width: 100%; }
  th, td { border: 1px solid #ccc; padding: 5px; text-align: center; }
  th { background: #eee; }
</style>
</head>
<body>
<h1>Forex Momentum + ROC Streak Alerts</h1>
<p>Symbol: <strong id="symbol">EUR/USD</strong></p>
<p>Interval: <strong id="interval">5min</strong></p>

<div id="notification-summary"></div>

<script>
const API_KEY = 'YOUR_TWELVE_DATA_KEY'; // Replace with your key
const SYMBOL = 'EUR/USD';
const INTERVAL = '5min';
const MOM_LENGTH = 10;
const ROC_LENGTH = 14;
const BIN_SIZE = 20; 
const BINS = [];
for(let i=-100;i<100;i+=BIN_SIZE) BINS.push(i);

let candles = []; // Cached candles
let topZones = [];
let lastCandleTime = null;
let notificationLog = [];

// ----------------- Utility Functions -----------------
function normalizedMomentum(closeArr, index){
    if(index < MOM_LENGTH) return 0;
    const mom = closeArr[index] - closeArr[index - MOM_LENGTH];
    let maxAbs = 0;
    for(let i=index-MOM_LENGTH+1;i<=index;i++){
        if(i>=MOM_LENGTH){
            const m = Math.abs(closeArr[i]-closeArr[i-MOM_LENGTH]);
            if(m>maxAbs) maxAbs = m;
        }
    }
    if(maxAbs===0) return 0;
    return Math.max(-100, Math.min(100,(mom/maxAbs)*100));
}

function normalizedROC(closeArr,index){
    if(index < ROC_LENGTH) return 0;
    const r = ((closeArr[index]-closeArr[index-ROC_LENGTH])/closeArr[index-ROC_LENGTH])*100;
    let maxAbs=0;
    for(let i=index-ROC_LENGTH+1;i<=index;i++){
        if(i>=ROC_LENGTH){
            const tempR=Math.abs((closeArr[i]-closeArr[i-ROC_LENGTH])/closeArr[i-ROC_LENGTH]*100);
            if(tempR>maxAbs) maxAbs=tempR;
        }
    }
    if(maxAbs===0) return 0;
    return Math.max(-100, Math.min(100,(r/maxAbs)*100));
}

// ----------------- Fetch Historical Candles -----------------
async function fetchHistoricalCandles(){
    const url = `https://api.twelvedata.com/time_series?symbol=${SYMBOL}&interval=${INTERVAL}&outputsize=1000&apikey=${API_KEY}`;
    const resp = await fetch(url);
    const data = await resp.json();
    if(data.status==="error"){ console.error(data); return []; }
    return data.values.reverse();
}

// ----------------- Fetch Only Latest Candles -----------------
async function fetchLatestCandles(){
    const url = `https://api.twelvedata.com/time_series?symbol=${SYMBOL}&interval=${INTERVAL}&outputsize=20&apikey=${API_KEY}`;
    const resp = await fetch(url);
    const data = await resp.json();
    if(data.status==="error"){ console.error(data); return []; }
    return data.values.reverse();
}

// ----------------- Find Top Zones -----------------
function findTopZones(candles){
    const closeArr = candles.map(c=>parseFloat(c.close));
    const streaksBull={}, streaksBear={};
    const heatmapBull={}, heatmapBear={};

    BINS.forEach(m=>{
        streaksBull[m]={}; streaksBear[m]={};
        heatmapBull[m]={}; heatmapBear[m]={};
        BINS.forEach(r=>{
            streaksBull[m][r]=[]; streaksBear[m][r]=[];
            heatmapBull[m][r]=0; heatmapBear[m][r]=0;
        });
    });

    let consecutiveCount = 1;
    for(let i=Math.max(MOM_LENGTH,ROC_LENGTH); i<closeArr.length; i++){
        const mom = normalizedMomentum(closeArr,i);
        const roc = normalizedROC(closeArr,i);
        const dir = closeArr[i] > closeArr[i-1]? 'Bull':'Bear';
        const prevDir = closeArr[i-1] > closeArr[i-2]? 'Bull':'Bear';
        consecutiveCount = (dir===prevDir)? consecutiveCount+1 : 1;

        if(consecutiveCount >= 2){
            const momBin=BINS.reduce((p,c)=>Math.abs(c-mom)<Math.abs(p-mom)?c:p,BINS[0]);
            const rocBin=BINS.reduce((p,c)=>Math.abs(c-roc)<Math.abs(p-roc)?c:p,BINS[0]);
            if(dir==='Bull'){
                streaksBull[momBin][rocBin].push(consecutiveCount);
                heatmapBull[momBin][rocBin]++;
            } else {
                streaksBear[momBin][rocBin].push(consecutiveCount);
                heatmapBear[momBin][rocBin]++;
            }
        }
    }

    const collectZones = (heatmap, streaks, direction) => {
        const zones=[];
        BINS.forEach(m=>BINS.forEach(r=>{
            if(heatmap[m][r]>0){
                zones.push({
                    momentum: m,
                    roc: r,
                    direction: direction,
                    streaks: streaks[m][r],
                    freq: heatmap[m][r],
                    longest: Math.max(...streaks[m][r])
                });
            }
        }));
        zones.sort((a,b)=>b.freq - a.freq);
        return zones.slice(0,3);
    }

    return [
        ...collectZones(heatmapBull, streaksBull,'Bull'),
        ...collectZones(heatmapBear, streaksBear,'Bear')
    ];
}

// ----------------- Check Latest Candle -----------------
function checkCandle(candle){
    if(lastCandleTime === candle.datetime) return;
    lastCandleTime = candle.datetime;

    const closeArr = candles.map(c=>parseFloat(c.close));
    const index = candles.length-1;
    const mom = normalizedMomentum(closeArr, index);
    const roc = normalizedROC(closeArr, index);

    topZones.forEach(zone=>{
        if(mom >= zone.momentum && mom < zone.momentum+BIN_SIZE &&
           roc >= zone.roc && roc < zone.roc+BIN_SIZE){

            const avgStreak = Math.round(zone.streaks.reduce((a,b)=>a+b,0)/zone.streaks.length);
            const maxStreak = Math.max(...zone.streaks);

            sendNotification(zone, avgStreak, maxStreak, candle.datetime);
        }
    });

    updateActualStreaks();
    showNotificationSummary();
}

// ----------------- Send Browser Notification -----------------
function sendNotification(zone, avgStreak, maxStreak, candleTime){
    const body = `${zone.direction} streak likely ~${avgStreak} candles (max: ${maxStreak})\n`+
                 `Momentum: ${zone.momentum}-${zone.momentum+BIN_SIZE}, ROC: ${zone.roc}-${zone.roc+BIN_SIZE}`;

    if("Notification" in window && Notification.permission==="granted"){
        new Notification(`Top Zone Alert!`, { body });
    } else if("Notification" in window && Notification.permission!=="denied"){
        Notification.requestPermission().then(p=>{
            if(p==="granted") new Notification(`Top Zone Alert!`, { body });
        });
    }

    notificationLog.push({
        candleTime: candleTime,
        direction: zone.direction,
        momentum: zone.momentum,
        roc: zone.roc,
        estimated: avgStreak,
        actual: null
    });
}

// ----------------- Update Actual Streaks -----------------
function updateActualStreaks(){
    const closeArr = candles.map(c=>parseFloat(c.close));
    notificationLog.forEach(entry => {
        if(entry.actual === null){
            const startIndex = candles.findIndex(c => c.datetime === entry.candleTime);
            if(startIndex >= 0){
                let count = 1;
                const dir = entry.direction;
                for(let i=startIndex+1; i<closeArr.length; i++){
                    const currDir = closeArr[i] > closeArr[i-1] ? 'Bull' : 'Bear';
                    if(currDir === dir) count++;
                    else break;
                }
                entry.actual = count;
            }
        }
    });
}

// ----------------- Display Summary Table -----------------
function showNotificationSummary(){
    if(notificationLog.length===0) return;
    let table = '<table><tr><th>Time</th><th>Dir</th><th>Momentum</th><th>ROC</th><th>Est Streak</th><th>Actual Streak</th></tr>';
    notificationLog.forEach(n=>{
        table += `<tr>
            <td>${n.candleTime}</td>
            <td>${n.direction}</td>
            <td>${n.momentum}</td>
            <td>${n.roc}</td>
            <td>${n.estimated}</td>
            <td>${n.actual !== null ? n.actual : '-'}</td>
        </tr>`;
    });
    table += '</table>';
    document.getElementById('notification-summary').innerHTML = table;
}

// ----------------- Main -----------------
async function main(){
    candles = await fetchHistoricalCandles();
    if(candles.length===0){ alert("No data fetched!"); return; }

    topZones = findTopZones(candles);

    if("Notification" in window && Notification.permission!=="granted"){
        Notification.requestPermission();
    }

    // Check latest candles every minute (only last 20)
    setInterval(async ()=>{
        const latestCandles = await fetchLatestCandles();
        latestCandles.forEach(c => {
            if(!candles.find(x=>x.datetime===c.datetime)) candles.push(c);
        });
        if(candles.length>0) checkCandle(candles[candles.length-1]);
    }, 60*1000);
}

document.getElementById('symbol').innerText = SYMBOL;
document.getElementById('interval').innerText = INTERVAL;
main();
</script>
</body>
</html>
