<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>EUUSD 5-min Streaks & Indicators</title>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; }
  #progressContainer { width: 100%; background: #eee; border-radius: 5px; overflow: hidden; margin-bottom: 20px; }
  #progressBar { width: 0%; height: 25px; background: #4caf50; text-align: center; color: white; line-height: 25px; }
  table { border-collapse: collapse; width: 100%; }
  th, td { border: 1px solid #ccc; padding: 5px; text-align: center; }
  th { background: #f4f4f4; }
</style>
</head>
<body>

<h2>EUUSD 5-min Streaks & Normalized Indicators</h2>

<div id="progressContainer">
  <div id="progressBar">0%</div>
</div>

<table id="streakTable">
  <thead>
    <tr>
      <th>Time</th>
      <th>Direction</th>
      <th>Streak</th>
      <th>AO %</th>
      <th>ROC %</th>
      <th>MACD Histogram %</th>
      <th>MOM %</th>
    </tr>
  </thead>
  <tbody></tbody>
</table>

<script>
const API_LIMIT = 8; // max requests per minute
const FETCH_INTERVAL = 7500; // 60,000 / 8 ~ 7.5 seconds per request

// Placeholder function to simulate API call to Twelve Data
async function fetchCandleData(start, end) {
    // Replace this with actual Twelve Data fetch code
    // Example endpoint: `https://api.twelvedata.com/time_series?symbol=EUR/USD&interval=5min&outputsize=500&apikey=YOUR_API_KEY`
    return new Promise(resolve => {
        setTimeout(() => {
            // Simulate 10 candles
            const data = [];
            let price = 1.08;
            for (let i = 0; i < 10; i++) {
                price += (Math.random() - 0.5) * 0.002;
                data.push({
                    datetime: new Date(start.getTime() + i*5*60000).toISOString(),
                    close: price,
                    ao: Math.random() * 2 - 1,       // -1 to 1
                    roc: Math.random() * 2 - 1,
                    macd_hist: Math.random() * 2 - 1,
                    mom: Math.random() * 2 - 1
                });
            }
            resolve(data);
        }, 500);
    });
}

// Normalize indicator to 0-100% scale
function normalize(value, min, max) {
    if (max === min) return 50;
    return ((value - min) / (max - min)) * 100;
}

// Detect streaks of 3+ consecutive candles in one direction
function detectStreaks(candles) {
    const streaks = [];
    let currentStreak = [];
    for (let i = 0; i < candles.length; i++) {
        const dir = i === 0 ? null : candles[i].close > candles[i-1].close ? 'Bull' : 'Bear';
        if (currentStreak.length === 0 || currentStreak[0].direction === dir) {
            currentStreak.push({ ...candles[i], direction: dir });
        } else {
            if (currentStreak.length >= 3) streaks.push([...currentStreak]);
            currentStreak = [{ ...candles[i], direction: dir }];
        }
    }
    if (currentStreak.length >= 3) streaks.push(currentStreak);
    return streaks;
}

// Update HTML table
function updateTable(streaks) {
    const tbody = document.querySelector('#streakTable tbody');
    tbody.innerHTML = '';
    streaks.forEach(streak => {
        streak.forEach(c => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${c.datetime}</td>
                <td>${c.direction}</td>
                <td>${streak.length}</td>
                <td>${c.ao.toFixed(1)}</td>
                <td>${c.roc.toFixed(1)}</td>
                <td>${c.macd_hist.toFixed(1)}</td>
                <td>${c.mom.toFixed(1)}</td>
            `;
            tbody.appendChild(row);
        });
    });
}

// Update progress bar
function updateProgress(percent) {
    const bar = document.getElementById('progressBar');
    bar.style.width = percent + '%';
    bar.textContent = percent + '%';
}

// Main function
async function main() {
    const start = new Date(Date.now() - 60*60*1000); // 1 hour ago
    const end = new Date();

    // Fetch data in batches respecting API limit
    const totalRequests = 8; // max 8 per minute
    let allCandles = [];
    for (let i = 0; i < totalRequests; i++) {
        const data = await fetchCandleData(start, end);
        allCandles = allCandles.concat(data);
        updateProgress(Math.round((i+1)/totalRequests*100));
        await new Promise(res => setTimeout(res, FETCH_INTERVAL));
    }

    // Calculate min/max for normalization
    const indicators = ['ao', 'roc', 'macd_hist', 'mom'];
    const mins = {}, maxs = {};
    indicators.forEach(ind => {
        mins[ind] = Math.min(...allCandles.map(c => c[ind]));
        maxs[ind] = Math.max(...allCandles.map(c => c[ind]));
    });

    // Normalize indicators
    allCandles.forEach(c => {
        indicators.forEach(ind => {
            c[ind] = normalize(c[ind], mins[ind], maxs[ind]);
        });
    });

    // Detect streaks
    const streaks = detectStreaks(allCandles);

    // Update table
    updateTable(streaks);
    updateProgress(100);
}

main();
</script>
</body>
</html>
